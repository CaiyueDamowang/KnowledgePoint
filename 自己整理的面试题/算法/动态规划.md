详解: http://www.sohu.com/a/153858619_466939


动态规划的英文名Dynamic programming 是一种分阶段求解决策问题的数学思想 它不止用于编程领域 也应用于管理学 经济学 生物学

大事化小 小事化了




题目：------------------------
有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。

复杂的问题分阶段进行简化 逐步简化成简单的问题 这就是动态规划的思想  

f(n) = f(n - 1) + f(n - 2)
fn(10) = f(9) + f(8)
f(9) = f(8) + f(7)
f(8) = f(7) + f(6)
...
f(2) = 2
f(1) = 1




// 递归求解
function getClimbingWays(n) {
    if(n < 0) {
        return 0;
    }
    if(n === 1) {
        return 1;
    }
    if(n === 2) {
        return 2;
    }
    return getClimbingWays(n - 1) + getClimbingWays(n - 2);
}

时间复杂度O(2^N)

缺点: 有些相同的参数被重复计算了 越往下 重复的越多




// 备忘录算法 (用缓存 先创建一个哈希表 当遇到相同的参数时 再从哈希表里取出 就不用重复计算了)

 function getClimbingWays(n) {
    if(n < 0) {
        return 0;
    }
    if(n === 1) {
        return 1;
    }
    if(n === 2) {
        return 2;
    }
    
    var map = new Map();
    if(map.get(n)) {
        return map.get(n);
    }else {
        var value = getClimbingWays(n - 1) + getClimbingWays(n - 2);
        map.set(n, value);
        return value;
    }
}

在以上代码中，集合map是一个备忘录。当每次需要计算F(N)的时候，会首先从map中寻找匹配元素。如果map中存在，就直接返回结果，如果map中不存在，就计算出结果，存入备忘录中

时间复杂度和空间复杂度都是O(N) 因为从F(1)到F(N)一共有N个不同的输入 在哈希表里存了N-2个结果
时间复杂度不能再小了 空间复杂度可以再减小

前面都是自顶向下的 但我们可以自底向上的 




// 动态规划
function getClimbingWays(n) {
    if(n < 0) {
        return 0;
    }
    if(n === 1) {
        return 1;
    }
    if(n === 2) {
        return 2;
    }
    
    var a = 1;
    var b = 2;
    var temp = 0;
    
    for(var i = 3; i <= n; i++) {
       temp = a + b;
        a = b;
        b = temp;
    }
    return temp;
}

时间复杂度是O(N) 由于只引入了两个或三个变量 所以空间复杂度只有O(1)




题目二： 国王和金矿-------------------------------
有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

// 500金/5人 200金/3人 300金/4人 350金/3人 400金/5人
        
// 每一座金矿都有挖与不挖两种选择，如果有N座金矿
// ，排列组合起来就有2^N种选择。对所有可能性做遍历，
// 排除那些使用工人数超过10的选择，在剩下的选择里找出获得金币数最多的选择。
// 代码比较简单就不展示了，时间复杂度也很明显，就是O(2^N)。


// 动态规划有三个核心元素 最优子结构 边界 状态转移方程式   








